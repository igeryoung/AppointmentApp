import 'dart:io';
import 'dart:convert';

import 'package:http/http.dart' as http;
import 'package:http/io_client.dart';
import 'package:uuid/uuid.dart';

Map<String, String> _loadEnvFile(String path) {
  final file = File(path);
  if (!file.existsSync()) return const {};

  final map = <String, String>{};
  final lines = file.readAsLinesSync();
  for (final rawLine in lines) {
    final line = rawLine.trim();
    if (line.isEmpty || line.startsWith('#')) continue;
    final idx = line.indexOf('=');
    if (idx <= 0) continue;
    final key = line.substring(0, idx).trim();
    final value = line.substring(idx + 1).trim();
    if (key.isEmpty) continue;
    map[key] = value;
  }
  return map;
}

String _resolveValue({
  required String key,
  required Map<String, String> fileEnv,
}) {
  final fromProcess = Platform.environment[key]?.trim();
  if (fromProcess != null && fromProcess.isNotEmpty) return fromProcess;
  final fromFile = fileEnv[key]?.trim();
  if (fromFile != null && fromFile.isNotEmpty) return fromFile;
  return '';
}

String _pickString(Map<String, dynamic> map, {required List<String> keys}) {
  for (final key in keys) {
    final value = map[key];
    if (value != null && value.toString().trim().isNotEmpty) {
      return value.toString();
    }
  }
  throw StateError('Missing expected keys: ${keys.join(', ')}');
}

Future<void> main() async {
  final envFilePath =
      Platform.environment['SN_TEST_ENV_FILE']?.trim().isNotEmpty == true
      ? Platform.environment['SN_TEST_ENV_FILE']!.trim()
      : '.env.integration';
  final fileEnv = _loadEnvFile(envFilePath);

  final baseUrl = _resolveValue(key: 'SN_TEST_BASE_URL', fileEnv: fileEnv);
  final deviceId = _resolveValue(key: 'SN_TEST_DEVICE_ID', fileEnv: fileEnv);
  final deviceToken = _resolveValue(
    key: 'SN_TEST_DEVICE_TOKEN',
    fileEnv: fileEnv,
  );

  if (baseUrl.isEmpty || deviceId.isEmpty || deviceToken.isEmpty) {
    stderr.writeln(
      'Missing required config. Set SN_TEST_BASE_URL, SN_TEST_DEVICE_ID, '
      'SN_TEST_DEVICE_TOKEN (env or $envFilePath).',
    );
    exitCode = 64;
    return;
  }

  final uuid = const Uuid();
  final suffix = DateTime.now().millisecondsSinceEpoch.toString();
  final client = _buildClient(baseUrl);

  try {
    final createdBook = await _createBook(
      client: client,
      baseUrl: baseUrl,
      name: 'IT metadata fixture $suffix',
      deviceId: deviceId,
      deviceToken: deviceToken,
    );
    final bookUuid = _pickString(
      createdBook,
      keys: const ['bookUuid', 'book_uuid', 'uuid'],
    );

    final eventId = uuid.v4();
    final recordUuid = uuid.v4();
    final startTime = DateTime.now().toUtc().add(const Duration(minutes: 30));
    final endTime = startTime.add(const Duration(minutes: 30));

    await _createEvent(
      client: client,
      baseUrl: baseUrl,
      bookUuid: bookUuid,
      eventData: {
        'id': eventId,
        'record_uuid': recordUuid,
        'title': 'IT metadata fixture $suffix',
        'record_number': 'IT-$suffix',
        'record_name': 'IT Fixture $suffix',
        'record_phone': null,
        'event_types': const ['consultation'],
        'start_time': startTime.millisecondsSinceEpoch ~/ 1000,
        'end_time': endTime.millisecondsSinceEpoch ~/ 1000,
      },
      deviceId: deviceId,
      deviceToken: deviceToken,
    );

    final file = File(envFilePath);
    final content =
        '''
# Generated by tool/create_event_metadata_fixture.dart
SN_TEST_BASE_URL=$baseUrl
SN_TEST_DEVICE_ID=$deviceId
SN_TEST_DEVICE_TOKEN=$deviceToken
SN_TEST_BOOK_UUID=$bookUuid
SN_TEST_EVENT_ID=$eventId
SN_TEST_RECORD_UUID=$recordUuid
''';
    await file.writeAsString(content);

    stdout.writeln('Created integration fixture successfully.');
    stdout.writeln('Wrote config to $envFilePath');
    stdout.writeln('');
    stdout.writeln('Book UUID: $bookUuid');
    stdout.writeln('Event ID: $eventId');
    stdout.writeln('Record UUID: $recordUuid');
    stdout.writeln('');
    stdout.writeln(
      'Run test: flutter test test/app/integration/event_metadata_server_smoke_test.dart',
    );
  } catch (e) {
    stderr.writeln('Failed to create integration fixture: $e');
    exitCode = 1;
  } finally {
    client.close();
  }
}

http.Client _buildClient(String baseUrl) {
  final isHttps = baseUrl.startsWith('https://');
  if (!isHttps) {
    return http.Client();
  }

  final allowBadCert =
      (Platform.environment['SN_TEST_ALLOW_BAD_CERT'] ?? '1') != '0';
  final ioClient = HttpClient();
  if (allowBadCert) {
    ioClient.badCertificateCallback = (_, __, ___) => true;
  }
  return IOClient(ioClient);
}

Future<Map<String, dynamic>> _createBook({
  required http.Client client,
  required String baseUrl,
  required String name,
  required String deviceId,
  required String deviceToken,
}) async {
  final response = await client
      .post(
        Uri.parse('$baseUrl/api/books'),
        headers: {
          'Content-Type': 'application/json',
          'X-Device-ID': deviceId,
          'X-Device-Token': deviceToken,
        },
        body: jsonEncode({'name': name}),
      )
      .timeout(const Duration(seconds: 20));

  if (response.statusCode != 200) {
    throw StateError(
      'Create book failed: ${response.statusCode} ${response.body}',
    );
  }

  final body = jsonDecode(response.body) as Map<String, dynamic>;
  final book = body['book'];
  if (book is Map<String, dynamic>) {
    return {...book, 'uuid': book['bookUuid'] ?? book['book_uuid']};
  }
  return body;
}

Future<void> _createEvent({
  required http.Client client,
  required String baseUrl,
  required String bookUuid,
  required Map<String, dynamic> eventData,
  required String deviceId,
  required String deviceToken,
}) async {
  final response = await client
      .post(
        Uri.parse('$baseUrl/api/books/$bookUuid/events'),
        headers: {
          'Content-Type': 'application/json',
          'X-Device-ID': deviceId,
          'X-Device-Token': deviceToken,
        },
        body: jsonEncode(eventData),
      )
      .timeout(const Duration(seconds: 20));

  if (response.statusCode != 200) {
    throw StateError(
      'Create event failed: ${response.statusCode} ${response.body}',
    );
  }
}
