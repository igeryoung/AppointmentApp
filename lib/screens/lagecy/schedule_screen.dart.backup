import 'dart:async';
import 'dart:math';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:intl/intl.dart';
import '../cubits/schedule_cubit.dart';
import '../cubits/schedule_state.dart';
import '../l10n/app_localizations.dart';
import '../models/book.dart';
import '../models/event.dart';
import '../models/note.dart';
import '../models/schedule_drawing.dart';
import '../services/database_service_interface.dart';
import '../services/prd_database_service.dart';
import '../services/web_prd_database_service.dart';
import '../services/time_service.dart';
import '../services/content_service.dart';
import '../services/cache_manager.dart';
import '../services/api_client.dart';
import '../services/server_config_service.dart';
import '../widgets/handwriting_canvas.dart';
import '../utils/schedule/schedule_test_utils.dart';
import '../utils/schedule/schedule_cache_utils.dart';
import '../utils/schedule/schedule_layout_utils.dart';
import '../widgets/schedule/test_menu.dart';
import 'event_detail_screen.dart';

/// Schedule screen implementing 3-Day view only
class ScheduleScreen extends StatefulWidget {
  final Book book;

  const ScheduleScreen({
    super.key,
    required this.book,
  });

  @override
  State<ScheduleScreen> createState() => _ScheduleScreenState();
}

class _ScheduleScreenState extends State<ScheduleScreen> with WidgetsBindingObserver {
  late TransformationController _transformationController;
  DateTime _selectedDate = TimeService.instance.now();

  // ContentService for server sync
  ContentService? _contentService;

  // CacheManager for experimental cache operations
  CacheManager? _cacheManager;

  // Network connectivity monitoring
  StreamSubscription<ConnectivityResult>? _connectivitySubscription;
  bool _wasOfflineLastCheck = false;
  bool _isOffline = false;
  bool _isSyncing = false;

  // Date change detection
  DateTime _lastActiveDate = TimeService.instance.now();
  Timer? _dateCheckTimer;

  // Drawing overlay state
  bool _isDrawingMode = false;
  ScheduleDrawing? _currentDrawing;
  // Cache of canvas keys for each unique page (viewMode + date combination)
  final Map<String, GlobalKey<HandwritingCanvasState>> _canvasKeys = {};

  // Race condition prevention for drawing saves
  Timer? _saveDebounceTimer;
  bool _isSaving = false;
  int _lastSavedCanvasVersion = 0;

  // FAB menu visibility state
  bool _isFabMenuVisible = false;

  // Event menu and drag state
  Event? _selectedEventForMenu;
  Offset? _menuPosition;

  // Time range settings (now using ScheduleLayoutUtils)
  static const int _startHour = ScheduleLayoutUtils.startHour;
  static const int _endHour = ScheduleLayoutUtils.endHour;
  static const int _totalSlots = ScheduleLayoutUtils.totalSlots;

  // Use appropriate database service based on platform
  IDatabaseService get _dbService => kIsWeb
      ? WebPRDDatabaseService()
      : PRDDatabaseService();

  @override
  void initState() {
    super.initState();
    _transformationController = TransformationController();

    // Register lifecycle observer
    WidgetsBinding.instance.addObserver(this);

    // Start periodic date checking (every minute)
    _startDateCheckTimer();

    // Initialize ContentService for server sync and auto-sync dirty notes
    _initializeContentService();

    // Setup network connectivity monitoring for automatic sync retry
    _setupConnectivityMonitoring();

    // Cubit is initialized in BlocProvider - it automatically loads events
    _loadDrawing();
  }

  /// Initialize ContentService for server sync
  Future<void> _initializeContentService() async {
    try {
      final prdDb = _dbService as PRDDatabaseService;
      final serverConfig = ServerConfigService(prdDb);
      final serverUrl = await serverConfig.getServerUrlOrDefault(
        defaultUrl: 'http://localhost:8080',
      );
      final apiClient = ApiClient(baseUrl: serverUrl);
      _cacheManager = CacheManager(prdDb);
      _contentService = ContentService(apiClient, _cacheManager!, _dbService);
      debugPrint('‚úÖ ScheduleScreen: ContentService initialized');

      // Check server connectivity
      final serverReachable = await _checkServerConnectivity();
      setState(() {
        _isOffline = !serverReachable;
        _wasOfflineLastCheck = !serverReachable;
      });

      context.read<ScheduleCubit>().setOfflineStatus(_isOffline);

      debugPrint('‚úÖ ScheduleScreen: Initial connectivity check - offline: $_isOffline');

      // Auto-sync dirty notes for this book if online
      if (serverReachable) {
        _autoSyncDirtyNotes();
      }

      // Preloading is now triggered automatically by BlocListener when events are loaded
    } catch (e) {
      debugPrint('‚ùå ScheduleScreen: Failed to initialize ContentService: $e');
      // Continue without ContentService - sync will not work but UI remains functional
      setState(() {
        _isOffline = true;
      });

      if (mounted) {
        context.read<ScheduleCubit>().setOfflineStatus(_isOffline);
      }
    }
  }

  /// Setup network connectivity monitoring for automatic sync retry
  void _setupConnectivityMonitoring() {
    debugPrint('üåê ScheduleScreen: Setting up connectivity monitoring...');

    _connectivitySubscription = Connectivity().onConnectivityChanged.listen(
      (ConnectivityResult result) {
        _onConnectivityChanged(result);
      },
    );

    // Also check initial connectivity state
    Connectivity().checkConnectivity().then((result) {
      _onConnectivityChanged(result);
    });
  }

  /// Check actual server connectivity using health check
  /// Returns true if server is reachable, false otherwise
  Future<bool> _checkServerConnectivity() async {
    if (_contentService == null) {
      debugPrint('‚ö†Ô∏è ScheduleScreen: Cannot check server - ContentService not initialized');
      return false;
    }

    try {
      debugPrint('üîç ScheduleScreen: Checking server connectivity via health check...');
      final isHealthy = await _contentService!.healthCheck();
      debugPrint(isHealthy
        ? '‚úÖ ScheduleScreen: Server is reachable'
        : '‚ùå ScheduleScreen: Server health check returned false');
      return isHealthy;
    } catch (e) {
      debugPrint('‚ùå ScheduleScreen: Server health check failed: $e');
      return false;
    }
  }

  /// Handle connectivity changes - automatically retry sync when network returns
  void _onConnectivityChanged(ConnectivityResult result) {
    final hasConnection = result != ConnectivityResult.none;

    debugPrint('üåê ScheduleScreen: Connectivity changed - hasConnection: $hasConnection, result: $result');

    // Verify actual server connectivity, not just network interface status
    Future.microtask(() async {
      final serverReachable = await _checkServerConnectivity();
      final wasOfflineBefore = _wasOfflineLastCheck;

      if (mounted) {
        setState(() {
          _isOffline = !serverReachable;
          _wasOfflineLastCheck = !serverReachable;
        });

        context.read<ScheduleCubit>().setOfflineStatus(_isOffline);

        debugPrint('üåê ScheduleScreen: Offline state updated based on server check: $_isOffline');

        // Network just came back online - auto-sync dirty notes
        if (serverReachable && wasOfflineBefore) {
          debugPrint('üåê ScheduleScreen: Server restored! Auto-syncing dirty notes...');

          // Wait a bit for network to stabilize
          Future.delayed(const Duration(seconds: 1), () {
            if (mounted && !_isSyncing) {
              _autoSyncDirtyNotes();
            }
          });
        }
      }
    });
  }

  /// Auto-sync dirty notes for this book in background
  Future<void> _autoSyncDirtyNotes() async {
    if (_contentService == null || _isSyncing || widget.book.id == null) return;

    setState(() {
      _isSyncing = true;
    });

    try {
      debugPrint('üîÑ ScheduleScreen: Auto-syncing dirty notes for book ${widget.book.id}...');

      final result = await _contentService!.syncDirtyNotesForBook(widget.book.id!);

      if (mounted) {
        setState(() {
          _isSyncing = false;
        });

        // Show user feedback
        if (result.nothingToSync) {
          debugPrint('‚úÖ ScheduleScreen: No dirty notes to sync');
        } else if (result.allSucceeded) {
          debugPrint('‚úÖ ScheduleScreen: All ${result.total} notes synced successfully');
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Synced ${result.total} offline note${result.total > 1 ? 's' : ''}'),
              backgroundColor: Colors.green,
              duration: const Duration(seconds: 2),
            ),
          );
        } else if (result.hasFailures) {
          debugPrint('‚ö†Ô∏è ScheduleScreen: ${result.success}/${result.total} notes synced, ${result.failed} failed');
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Synced ${result.success}/${result.total} notes. ${result.failed} failed - check if book is backed up'),
              backgroundColor: Colors.orange,
              duration: const Duration(seconds: 5),
              action: SnackBarAction(
                label: 'Details',
                textColor: Colors.white,
                onPressed: () {
                  // Show dialog with more info
                  showDialog(
                    context: context,
                    builder: (context) => AlertDialog(
                      title: const Text('Sync Failed'),
                      content: const Text(
                        'Some notes failed to sync because the book doesn\'t exist on the server yet.\n\n'
                        'Solution: Use the book backup feature to sync the book to the server first.',
                      ),
                      actions: [
                        TextButton(
                          onPressed: () => Navigator.pop(context),
                          child: const Text('OK'),
                        ),
                      ],
                    ),
                  );
                },
              ),
            ),
          );
        }
      }
    } catch (e) {
      debugPrint('‚ùå ScheduleScreen: Auto-sync failed: $e');
      if (mounted) {
        setState(() {
          _isSyncing = false;
        });
      }
    }
  }

  @override
  void dispose() {
    // Unregister lifecycle observer
    WidgetsBinding.instance.removeObserver(this);

    // Cancel network connectivity subscription
    _connectivitySubscription?.cancel();

    // Cancel date check timer
    _dateCheckTimer?.cancel();

    // Cancel debounced save timer
    _saveDebounceTimer?.cancel();

    // Close progress stream controller
    _progressController.close();

    _transformationController.dispose();
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);

    if (state == AppLifecycleState.resumed) {
      debugPrint('üìÖ App resumed - checking for date changes');
      _checkAndHandleDateChange();
    } else if (state == AppLifecycleState.paused || state == AppLifecycleState.inactive) {
      debugPrint('üìÖ App backgrounding - saving drawing if in drawing mode');
      // Auto-save drawing before going to background
      if (_isDrawingMode) {
        _saveDrawing();
      }
    }
  }

  /// Start timer to periodically check for date changes (every minute)
  void _startDateCheckTimer() {
    _dateCheckTimer = Timer.periodic(const Duration(minutes: 1), (timer) {
      _checkAndHandleDateChange();
    });
  }

  /// Check if the system date has changed and handle it
  Future<void> _checkAndHandleDateChange() async {
    final now = TimeService.instance.now();
    final currentDate = DateTime(now.year, now.month, now.day);
    final lastActiveDate = DateTime(_lastActiveDate.year, _lastActiveDate.month, _lastActiveDate.day);

    if (currentDate != lastActiveDate) {
      debugPrint('üìÖ Date changed detected: $lastActiveDate ‚Üí $currentDate');

      // Check if user is viewing a 3-day window that contains "today" (the new current date)
      final windowStart = _get3DayWindowStart_LOCAL(_selectedDate);
      final windowEnd = windowStart.add(const Duration(days: 3));
      // Check if the old "today" (lastActiveDate) is in the current viewing window
      final isViewingWindowContainingToday = lastActiveDate.isAfter(windowStart.subtract(const Duration(days: 1))) &&
                                          lastActiveDate.isBefore(windowEnd);

      if (isViewingWindowContainingToday) {
        debugPrint('üìÖ User was viewing window containing "today" - auto-updating to new today');

        // Save current drawing before switching dates
        if (_isDrawingMode) {
          await _saveDrawing();
        }

        // Update to new today
        setState(() {
          _selectedDate = now;
          _lastActiveDate = now;
        });

        if (mounted) {
          context.read<ScheduleCubit>().selectDate(_selectedDate);
        }

        // Reload drawing for new date
        await _loadDrawing();

        // Show notification to user
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text(AppLocalizations.of(context)!.dateChangedToToday),
              duration: const Duration(seconds: 2),
            ),
          );
        }
      } else {
        // User is viewing a different window - just update last active date
        debugPrint('üìÖ User viewing different window - keeping current view');
        _lastActiveDate = now;
      }
    }
  }

  /// Get unique page identifier for the current view and date
  String _getPageId() {
    // For 3-day view, use window start to keep same page across days in window
    final normalizedDate = _get3DayWindowStart_LOCAL(_selectedDate);
    return '3day_${normalizedDate.millisecondsSinceEpoch}';
  }

  /// Get or create canvas key for the current page
  GlobalKey<HandwritingCanvasState> _getCanvasKeyForCurrentPage() {
    final pageId = _getPageId();
    if (!_canvasKeys.containsKey(pageId)) {
      _canvasKeys[pageId] = GlobalKey<HandwritingCanvasState>();
    }
    return _canvasKeys[pageId]!;
  }

  Future<void> _loadDrawing() async {
    try {
      // Reset current drawing to avoid carrying old IDs
      setState(() {
        _currentDrawing = null;
      });

      // Use effective date to ensure consistency with UI rendering
      // For 3-Day View, this uses the window start date
      final effectiveDate = _getEffectiveDate_LOCAL();

      // Use ContentService for cache-first strategy with server fallback
      // This enables automatic server fetch when cache is empty
      ScheduleDrawing? drawing;
      if (_contentService != null) {
        debugPrint('üìñ Loading drawing via ContentService (cache-first with server fallback)...');
        drawing = await _contentService!.getDrawing(
          bookId: widget.book.id!,
          date: effectiveDate,
          viewMode: 1, // Always 3-day view (viewMode = 1)
          forceRefresh: false, // Use cache if available
        );
      } else {
        // Fallback to direct database access if ContentService not initialized
        debugPrint('‚ö†Ô∏è ContentService not available, loading drawing from cache only');
        drawing = await _dbService.getCachedDrawing(
          widget.book.id!,
          effectiveDate,
          1, // Always 3-day view (viewMode = 1)
        );
      }

      setState(() {
        _currentDrawing = drawing;
      });

      context.read<ScheduleCubit>().loadDrawing(viewMode: 1, forceRefresh: false);

      // Load strokes into canvas if drawing exists
      // Use post-frame callback to ensure canvas is ready
      WidgetsBinding.instance.addPostFrameCallback((_) {
        final canvasKey = _getCanvasKeyForCurrentPage();
        if (drawing != null && drawing.strokes.isNotEmpty) {
          debugPrint('üìñ Loading ${drawing.strokes.length} strokes for page ${_getPageId()} (effectiveDate: $effectiveDate)');
          canvasKey.currentState?.loadStrokes(drawing.strokes);
        } else {
          debugPrint('üìñ Clearing canvas for empty page ${_getPageId()} (effectiveDate: $effectiveDate)');
          canvasKey.currentState?.clear();
        }
      });
    } catch (e) {
      debugPrint('‚ùå Error loading drawing: $e');
    }
  }

  /// Preload notes for all events in current 3-day window (background, non-blocking)
  ///
  /// This method is automatically triggered by BlocListener when events are loaded
  /// from the ScheduleCubit. It improves UX by preloading notes so they're instantly
  /// available when user taps events.
  Future<void> _preloadNotesInBackground(List<Event> events) async {
    if (events.isEmpty) {
      debugPrint('üì¶ ScheduleScreen: No events to preload');
      return;
    }

    if (_contentService == null) {
      debugPrint('‚ö†Ô∏è ScheduleScreen: Cannot preload - ContentService not initialized');
      return;
    }

    final preloadStartTime = DateTime.now();
    debugPrint('üì¶ ScheduleScreen: [${preloadStartTime.toIso8601String()}] Starting preload for ${events.length} events');

    // Extract all event IDs (filter out null IDs)
    final eventIds = events
        .where((e) => e.id != null)
        .map((e) => e.id!)
        .toList();

    if (eventIds.isEmpty) {
      debugPrint('üì¶ ScheduleScreen: No valid event IDs to preload');
      return;
    }

    debugPrint('üì¶ ScheduleScreen: Calling ContentService.preloadNotes with ${eventIds.length} event IDs');

    try {
      // Call ContentService to preload notes with progress callback
      await _contentService!.preloadNotes(
        eventIds,
        onProgress: (loaded, total) {
          // Log progress for debugging
          debugPrint('üì¶ ScheduleScreen: Progress update - $loaded/$total notes loaded');
        },
      );

      final preloadEndTime = DateTime.now();
      final preloadDuration = preloadEndTime.difference(preloadStartTime);
      debugPrint('‚úÖ ScheduleScreen: Preload call completed in ${preloadDuration.inMilliseconds}ms (initiated for ${eventIds.length} notes)');
    } catch (e) {
      // Preload failure is non-critical - user can still use the app
      // Notes will be fetched on-demand when user taps events
      final preloadEndTime = DateTime.now();
      final preloadDuration = preloadEndTime.difference(preloadStartTime);
      debugPrint('‚ö†Ô∏è ScheduleScreen: Preload failed after ${preloadDuration.inMilliseconds}ms (non-critical): $e');
    }
  }

  /// Schedule a debounced save to reduce save frequency during fast drawing
  /// RACE CONDITION FIX: Debounce saves by 500ms to prevent excessive saves
  void _scheduleSaveDrawing() {
    _saveDebounceTimer?.cancel();
    _saveDebounceTimer = Timer(const Duration(milliseconds: 500), () {
      _saveDrawing();
    });
    debugPrint('‚è±Ô∏è Scheduled debounced save (500ms)');
  }

  Future<void> _saveDrawing() async {
    // RACE CONDITION FIX: Prevent concurrent saves
    if (_isSaving) {
      debugPrint('‚ö†Ô∏è Save already in progress, skipping...');
      return;
    }

    final canvasState = _getCanvasKeyForCurrentPage().currentState;
    if (canvasState == null) {
      debugPrint('‚ö†Ô∏è Cannot save: canvas state is null');
      return;
    }

    // Check if canvas version has changed since last save
    final currentCanvasVersion = canvasState.canvasVersion;
    if (currentCanvasVersion == _lastSavedCanvasVersion) {
      debugPrint('‚è© Canvas unchanged (version: $currentCanvasVersion), skipping save');
      return;
    }

    _isSaving = true;
    try {
      final strokes = canvasState.getStrokes();
      final now = TimeService.instance.now();

      // Use effective date to ensure consistency with UI rendering
      // For 3-Day View, this uses the window start date
      final effectiveDate = _getEffectiveDate_LOCAL();

      // Only use existing ID, createdAt, and version if it matches the current page
      // This prevents reusing old values when switching pages
      int? drawingId;
      DateTime? createdAt;
      int version = 1; // Default version for new drawings
      if (_currentDrawing != null &&
          _currentDrawing!.bookId == widget.book.id! &&
          _currentDrawing!.viewMode == 1 && // Always 3-day view (viewMode = 1)
          _currentDrawing!.date.year == effectiveDate.year &&
          _currentDrawing!.date.month == effectiveDate.month &&
          _currentDrawing!.date.day == effectiveDate.day) {
        drawingId = _currentDrawing!.id;
        createdAt = _currentDrawing!.createdAt;
        version = _currentDrawing!.version; // Preserve version for optimistic locking
      }

      final drawing = ScheduleDrawing(
        id: drawingId,
        bookId: widget.book.id!,
        date: effectiveDate,
        viewMode: 1, // Always 3-day view (viewMode = 1)
        strokes: strokes,
        version: version, // Use preserved version from current drawing
        createdAt: createdAt ?? now,
        updatedAt: now,
      );

      debugPrint('üíæ Saving ${strokes.length} strokes for page ${_getPageId()} (effectiveDate: $effectiveDate, id: $drawingId, version: $version)');

      // Use ContentService to save drawing (syncs to server and cache)
      // Falls back to direct database save if ContentService not available
      if (_contentService != null) {
        debugPrint('üíæ Saving drawing via ContentService (syncs to server + cache)...');
        await _contentService!.saveDrawing(drawing);

        // RACE CONDITION FIX: Check if canvas changed during async save
        final currentStateAfterSave = _getCanvasKeyForCurrentPage().currentState;
        if (currentStateAfterSave != null &&
            currentStateAfterSave.canvasVersion != currentCanvasVersion) {
          debugPrint('‚ö†Ô∏è Canvas changed during save (v$currentCanvasVersion ‚Üí v${currentStateAfterSave.canvasVersion}), skipping state update');
          return; // Don't update _currentDrawing with stale data
        }

        // Update current drawing state - fetch back from cache to get server-assigned ID
        final savedDrawing = await _dbService.getCachedDrawing(
          widget.book.id!,
          effectiveDate,
          1,
        );
        if (mounted) {
          setState(() {
            _currentDrawing = savedDrawing ?? drawing;
          });
        }

        if (mounted) {
          context.read<ScheduleCubit>().saveDrawing(savedDrawing ?? drawing);
        }
      } else {
        debugPrint('‚ö†Ô∏è ContentService not available, saving to cache only');
        final savedDrawing = await _dbService.saveCachedDrawing(drawing);

        // RACE CONDITION FIX: Check if canvas changed during async save
        final currentStateAfterSave = _getCanvasKeyForCurrentPage().currentState;
        if (currentStateAfterSave != null &&
            currentStateAfterSave.canvasVersion != currentCanvasVersion) {
          debugPrint('‚ö†Ô∏è Canvas changed during save (v$currentCanvasVersion ‚Üí v${currentStateAfterSave.canvasVersion}), skipping state update');
          return; // Don't update _currentDrawing with stale data
        }

        if (mounted) {
          setState(() {
            _currentDrawing = savedDrawing;
          });
        }

        if (mounted) {
          context.read<ScheduleCubit>().saveDrawing(savedDrawing);
        }
      }

      debugPrint('‚úÖ Save successful, id: ${_currentDrawing?.id}');
      // Update last saved version to prevent redundant saves
      _lastSavedCanvasVersion = currentCanvasVersion;
    } catch (e) {
      debugPrint('‚ùå Error saving drawing: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(AppLocalizations.of(context)!.errorSavingDrawing(e.toString()))),
        );
      }
    } finally {
      _isSaving = false;
    }
  }

  Future<void> _toggleDrawingMode() async {
    if (_isDrawingMode) {
      // Exiting drawing mode - cancel pending debounced save and save immediately
      _saveDebounceTimer?.cancel();
      await _saveDrawing();
      setState(() {
        _isDrawingMode = false;
      });
    } else {
      // Entering drawing mode
      setState(() {
        _isDrawingMode = true;
      });
      // Load drawing after state update
      await _loadDrawing();
    }
  }

  void _toggleFabMenu() {
    setState(() {
      _isFabMenuVisible = !_isFabMenuVisible;
    });
  }

  DateTime _get3DayWindowStart_LOCAL(DateTime date) {
    // Use fixed anchor to calculate stable 3-day windows
    // This ensures the same 3-day window is shown even when the real-world date changes
    final anchor = DateTime(2000, 1, 1); // Fixed epoch anchor
    final daysSinceAnchor = date.difference(anchor).inDays;
    final windowIndex = daysSinceAnchor ~/ 3;
    final windowStart = anchor.add(Duration(days: windowIndex * 3));
    return DateTime(windowStart.year, windowStart.month, windowStart.day);
  }


  /// Get the effective date for data operations (loading/saving events and drawings)
  /// This ensures consistency between UI rendering and data layer
  DateTime _getEffectiveDate_LOCAL() {
    return _get3DayWindowStart_LOCAL(_selectedDate); // Always 3-day view
  }

  void _panToCurrentTime() {
    // Reset transformation to default view (scale 1.0, no pan)
    // At default zoom, all time slots are visible including current time
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      _transformationController.value = Matrix4.identity();
    });
  }

  Duration _getNavigationIncrement() {
    return const Duration(days: 3); // Always 3-day view
  }

  /// Check if currently viewing today's date
  bool _isViewingToday_LOCAL() {
    final now = TimeService.instance.now();
    final today = DateTime(now.year, now.month, now.day);
    final viewingDate = DateTime(_selectedDate.year, _selectedDate.month, _selectedDate.day);
    return viewingDate == today;
  }

  Future<void> _createEvent({DateTime? startTime}) async {
    final now = TimeService.instance.now();
    final defaultStartTime = startTime ??
        DateTime(now.year, now.month, now.day, now.hour, (now.minute ~/ 15) * 15);

    final newEvent = Event(
      bookId: widget.book.id!,
      name: '',
      recordNumber: '',
      eventType: '',
      startTime: defaultStartTime,
      createdAt: now,
      updatedAt: now,
    );

    final result = await Navigator.push<bool>(
      context,
      MaterialPageRoute(
        builder: (context) => EventDetailScreen(
          event: newEvent,
          isNew: true,
        ),
      ),
    );

    if (result == true) {
      context.read<ScheduleCubit>().loadEvents();
    }
  }

  Future<void> _editEvent(Event event) async {
    final result = await Navigator.push<bool>(
      context,
      MaterialPageRoute(
        builder: (context) => EventDetailScreen(
          event: event,
          isNew: false,
        ),
      ),
    );

    if (result == true) {
      context.read<ScheduleCubit>().loadEvents();
    }
  }

  void _showEventContextMenu(Event event, Offset position) {
    setState(() {
      _selectedEventForMenu = event;
      _menuPosition = position;
    });
  }

  void _closeEventMenu() {
    setState(() {
      _selectedEventForMenu = null;
      _menuPosition = null;
    });
  }

  Future<void> _handleMenuAction(String action, Event event) async {
    if (action == 'changeType') {
      await _changeEventType(event);
      _closeEventMenu();
    } else if (action == 'changeTime') {
      await _changeEventTimeFromSchedule(event);
      _closeEventMenu();
    } else if (action == 'remove') {
      await _removeEventFromSchedule(event);
      _closeEventMenu();
    } else if (action == 'delete') {
      await _deleteEventFromSchedule(event);
      _closeEventMenu();
    }
  }

  Future<void> _handleEventDrop(Event event, DateTime newStartTime) async {
    // Check if time actually changed
    if (event.startTime.year == newStartTime.year &&
        event.startTime.month == newStartTime.month &&
        event.startTime.day == newStartTime.day &&
        event.startTime.hour == newStartTime.hour &&
        event.startTime.minute == newStartTime.minute) {
      _closeEventMenu();
      return;
    }

    final l10n = AppLocalizations.of(context)!;

    // Show reason dialog
    final reason = await showDialog<String>(
      context: context,
      builder: (context) {
        final reasonController = TextEditingController(text: l10n.timeChangedViaDrag);
        return AlertDialog(
          title: Text(l10n.changeEventType),
          content: TextField(
            controller: reasonController,
            decoration: InputDecoration(
              labelText: l10n.reasonForTimeChangeLabel,
              hintText: l10n.enterReasonHint,
            ),
            autofocus: true,
            maxLines: 2,
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text(l10n.cancel),
            ),
            TextButton(
              onPressed: () {
                if (reasonController.text.trim().isNotEmpty) {
                  Navigator.pop(context, reasonController.text.trim());
                }
              },
              child: Text(l10n.ok),
            ),
          ],
        );
      },
    );

    if (reason != null && reason.isNotEmpty) {
      try {
        // Calculate new end time if original event had one
        DateTime? newEndTime;
        if (event.endTime != null) {
          final duration = event.endTime!.difference(event.startTime);
          newEndTime = newStartTime.add(duration);
        }

        final newEvent = await _dbService.changeEventTime(event, newStartTime, newEndTime, reason);
        _closeEventMenu();

        context.read<ScheduleCubit>().loadEvents();

        // Sync to server in background (best effort, no error handling needed)
        _syncEventToServer(newEvent);

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(l10n.eventTimeChangedSuccessfully)),
          );
        }
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(l10n.errorChangingTime(e.toString()))),
          );
        }
      }
    } else {
      _closeEventMenu();
    }
  }

  /// Sync event and note to server in background (best effort)
  Future<void> _syncEventToServer(Event event) async {
    if (_contentService == null) {
      debugPrint('‚ö†Ô∏è ScheduleScreen: ContentService not available, cannot sync event ${event.id}');
      return;
    }

    if (event.id == null) {
      debugPrint('‚ö†Ô∏è ScheduleScreen: Event ID is null, cannot sync');
      return;
    }

    try {
      debugPrint('üîÑ ScheduleScreen: Syncing event ${event.id} and note to server...');
      await _contentService!.syncNote(event.id!);
      debugPrint('‚úÖ ScheduleScreen: Event ${event.id} synced to server successfully');
    } catch (e) {
      // Silent failure - data is already saved locally and marked as dirty
      // It will be synced when the user opens the event detail screen
      debugPrint('‚ö†Ô∏è ScheduleScreen: Background sync failed (will retry later): $e');
    }
  }

  Future<void> _changeEventType(Event event) async {
    final l10n = AppLocalizations.of(context)!;
    final eventTypes = [
      l10n.consultation,
      l10n.surgery,
      l10n.followUp,
      l10n.emergency,
      l10n.checkUp,
      l10n.treatment,
    ];

    final selectedType = await showDialog<String>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.changeEventType),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: eventTypes.map((type) => ListTile(
            title: Text(type),
            leading: Radio<String>(
              value: type,
              groupValue: event.eventType,
              onChanged: (value) => Navigator.pop(context, value),
            ),
            onTap: () => Navigator.pop(context, type),
          )).toList(),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(l10n.cancel),
          ),
        ],
      ),
    );

    if (selectedType != null && selectedType != event.eventType) {
      try {
        final updatedEvent = event.copyWith(
          eventType: selectedType,
          updatedAt: TimeService.instance.now(),
        );

        await _dbService.updateEvent(updatedEvent);
        context.read<ScheduleCubit>().updateEvent(updatedEvent);

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(l10n.eventTypeChanged)),
          );
        }
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(l10n.errorUpdatingEvent(e.toString()))),
          );
        }
      }
    }
  }

  Future<void> _changeEventTimeFromSchedule(Event event) async {
    final l10n = AppLocalizations.of(context)!;

    final result = await showDialog<Map<String, dynamic>>(
      context: context,
      builder: (context) {
        DateTime newStartTime = event.startTime;
        DateTime? newEndTime = event.endTime;
        final reasonController = TextEditingController();
        bool showReasonError = false;

        return StatefulBuilder(
          builder: (context, setState) {
            final bool hasValidReason = reasonController.text.trim().isNotEmpty;

            return AlertDialog(
              title: Text(l10n.changeEventTime),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(l10n.changeTimeMessage),
                  const SizedBox(height: 16),
                  Row(
                    children: [
                      Expanded(
                        child: TextButton(
                          onPressed: () async {
                            final date = await showDatePicker(
                              context: context,
                              initialDate: newStartTime,
                              firstDate: DateTime.now().subtract(const Duration(days: 365)),
                              lastDate: DateTime.now().add(const Duration(days: 365)),
                            );
                            if (date == null) return;

                            final time = await showTimePicker(
                              context: context,
                              initialTime: TimeOfDay.fromDateTime(newStartTime),
                            );
                            if (time == null) return;

                            setState(() {
                              newStartTime = DateTime(date.year, date.month, date.day, time.hour, time.minute);
                            });
                          },
                          child: Text(
                            'Start: ${DateFormat('MMM d, HH:mm', Localizations.localeOf(context).toString()).format(newStartTime)}',
                            style: const TextStyle(fontSize: 12),
                          ),
                        ),
                      ),
                    ],
                  ),
                  Row(
                    children: [
                      Expanded(
                        child: TextButton(
                          onPressed: () async {
                            final date = await showDatePicker(
                              context: context,
                              initialDate: newEndTime ?? newStartTime,
                              firstDate: newStartTime,
                              lastDate: DateTime.now().add(const Duration(days: 365)),
                            );
                            if (date == null) return;

                            final time = await showTimePicker(
                              context: context,
                              initialTime: TimeOfDay.fromDateTime(newEndTime ?? newStartTime.add(const Duration(hours: 1))),
                            );
                            if (time == null) return;

                            setState(() {
                              newEndTime = DateTime(date.year, date.month, date.day, time.hour, time.minute);
                            });
                          },
                          child: Text(
                            newEndTime != null
                                ? 'End: ${DateFormat('MMM d, HH:mm', Localizations.localeOf(context).toString()).format(newEndTime!)}'
                                : 'Set End Time (Optional)',
                            style: const TextStyle(fontSize: 12),
                          ),
                        ),
                      ),
                      if (newEndTime != null)
                        IconButton(
                          onPressed: () => setState(() => newEndTime = null),
                          icon: const Icon(Icons.clear, size: 16),
                        ),
                    ],
                  ),
                  const SizedBox(height: 16),
                  Text(l10n.reasonForTimeChangeField, style: const TextStyle(fontWeight: FontWeight.w500)),
                  const SizedBox(height: 8),
                  TextField(
                    controller: reasonController,
                    decoration: InputDecoration(
                      hintText: l10n.enterReasonForTimeChange,
                      border: const OutlineInputBorder(),
                      errorText: showReasonError ? l10n.reasonRequired : null,
                      errorBorder: showReasonError
                          ? const OutlineInputBorder(borderSide: BorderSide(color: Colors.red))
                          : null,
                    ),
                    maxLines: 2,
                    autofocus: true,
                    onChanged: (value) {
                      setState(() {
                        showReasonError = false;
                      });
                    },
                  ),
                  if (showReasonError)
                    Padding(
                      padding: const EdgeInsets.only(top: 8),
                      child: Text(
                        l10n.reasonRequiredMessage,
                        style: const TextStyle(color: Colors.red, fontSize: 12),
                      ),
                    ),
                ],
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.pop(context, null),
                  child: Text(l10n.cancel),
                ),
                TextButton(
                  onPressed: () {
                    final reason = reasonController.text.trim();
                    if (reason.isEmpty) {
                      setState(() {
                        showReasonError = true;
                      });
                      return;
                    }
                    Navigator.pop(context, {
                      'startTime': newStartTime,
                      'endTime': newEndTime,
                      'reason': reason,
                    });
                  },
                  style: TextButton.styleFrom(
                    backgroundColor: hasValidReason ? Theme.of(context).primaryColor : Colors.grey.shade300,
                    foregroundColor: hasValidReason ? Colors.white : Colors.grey.shade600,
                  ),
                  child: Text(l10n.changeTimeButton),
                ),
              ],
            );
          },
        );
      },
    );

    if (result == null) return;

    try {
      // Use cubit method to change event time (creates new event + soft-deletes old)
      await context.read<ScheduleCubit>().changeEventTime(
        event,
        result['startTime'],
        result['endTime'],
        result['reason'],
      );

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(l10n.eventTimeChangedSuccess),
            backgroundColor: Colors.green,
            duration: const Duration(seconds: 2),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(l10n.errorChangingEventTime(e.toString())),
            backgroundColor: Colors.red,
            duration: const Duration(seconds: 3),
          ),
        );
      }
    }
  }

  Future<void> _removeEventFromSchedule(Event event) async {
    final l10n = AppLocalizations.of(context)!;

    // Show reason dialog
    final reason = await showDialog<String>(
      context: context,
      builder: (context) {
        final reasonController = TextEditingController();
        return AlertDialog(
          title: Text(l10n.removeEvent),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(l10n.removeEventDescription),
              const SizedBox(height: 12),
              TextField(
                controller: reasonController,
                decoration: InputDecoration(
                  labelText: l10n.reasonForRemovalLabel,
                  hintText: l10n.enterReasonHint,
                ),
                autofocus: true,
                maxLines: 2,
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text(l10n.cancel),
            ),
            TextButton(
              onPressed: () {
                if (reasonController.text.trim().isNotEmpty) {
                  Navigator.pop(context, reasonController.text.trim());
                }
              },
              style: TextButton.styleFrom(foregroundColor: Colors.orange),
              child: Text(l10n.ok),
            ),
          ],
        );
      },
    );

    if (reason != null && reason.isNotEmpty) {
      try {
        await context.read<ScheduleCubit>().deleteEvent(event.id!, reason: reason);

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(l10n.eventRemovedSuccessfully)),
          );
        }
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(l10n.errorRemovingEventMessage(e.toString()))),
          );
        }
      }
    }
  }

  Future<void> _deleteEventFromSchedule(Event event) async {
    final l10n = AppLocalizations.of(context)!;

    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.deleteEvent),
        content: Text(l10n.confirmDeleteEvent(event.name)),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text(l10n.cancel),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: Text(l10n.delete),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      try {
        // Use cubit method for hard delete (permanent deletion)
        await context.read<ScheduleCubit>().hardDeleteEvent(event.id!);

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(l10n.eventDeleted)),
          );
        }
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(l10n.errorDeletingEvent(e.toString()))),
          );
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final controller = TextEditingController(text: '5');
    bool clearAll = false;
    bool openEndOnly = false;

    final l10n = AppLocalizations.of(context)!;
    final result = await showDialog<Map<String, dynamic>>(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: Text(l10n.generateRandomEvents),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              TextField(
                controller: controller,
                decoration: InputDecoration(
                  labelText: l10n.numberOfEvents,
                  hintText: l10n.enterNumber,
                ),
                keyboardType: TextInputType.number,
                autofocus: true,
              ),
              const SizedBox(height: 16),
              CheckboxListTile(
                title: Text(l10n.clearAllExistingEventsFirst),
                value: clearAll,
                onChanged: (value) {
                  setState(() {
                    clearAll = value ?? false;
                  });
                },
                contentPadding: EdgeInsets.zero,
                dense: true,
              ),
              CheckboxListTile(
                title: Text(l10n.generateOpenEndedEventsOnly),
                subtitle: Text(l10n.noEndTime),
                value: openEndOnly,
                onChanged: (value) {
                  setState(() {
                    openEndOnly = value ?? false;
                  });
                },
                contentPadding: EdgeInsets.zero,
                dense: true,
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text(l10n.cancel),
            ),
            TextButton(
              onPressed: () {
                final value = int.tryParse(controller.text);
                if (value != null && value > 0 && value <= 50) {
                  Navigator.pop(context, {
                    'count': value,
                    'clearAll': clearAll,
                    'openEndOnly': openEndOnly,
                  });
                }
              },
              child: Text(l10n.generate),
            ),
          ],
        ),
      ),
    );

    if (result != null) {
      await _generateRandomEvents(
        result['count'] as int,
        clearAll: result['clearAll'] as bool,
        openEndOnly: result['openEndOnly'] as bool,
      );
    }
  }

  /// Show test time dialog for testing time change behavior
  Future<void> _showTestTimeDialog() async {
    final l10n = AppLocalizations.of(context)!;
    // If test mode is active, show option to reset
    if (TimeService.instance.isTestMode) {
      final reset = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: Text(l10n.testTimeActive),
          content: Text(
            l10n.currentTestTime(DateFormat('yyyy-MM-dd HH:mm:ss', Localizations.localeOf(context).toString()).format(TimeService.instance.overrideTime!)),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context, false),
              child: Text(l10n.cancel),
            ),
            TextButton(
              onPressed: () => Navigator.pop(context, true),
              style: TextButton.styleFrom(foregroundColor: Colors.red),
              child: Text(l10n.resetToRealTime),
            ),
          ],
        ),
      );

      if (reset == true) {
        TimeService.instance.resetToRealTime();
        setState(() {
          _selectedDate = TimeService.instance.now();
          _lastActiveDate = TimeService.instance.now();
        });

        if (mounted) {
          context.read<ScheduleCubit>().selectDate(_selectedDate);
        }

        await _loadDrawing();
      }
      return;
    }

    // Show date and time picker
    final selectedDate = await showDatePicker(
      context: context,
      initialDate: TimeService.instance.now(),
      firstDate: DateTime(2020),
      lastDate: DateTime(2030),
    );

    if (selectedDate == null || !mounted) return;

    final selectedTime = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(TimeService.instance.now()),
    );

    if (selectedTime == null || !mounted) return;

    final testTime = DateTime(
      selectedDate.year,
      selectedDate.month,
      selectedDate.day,
      selectedTime.hour,
      selectedTime.minute,
    );

    TimeService.instance.setTestTime(testTime);
    setState(() {
      _selectedDate = TimeService.instance.now();
      _lastActiveDate = TimeService.instance.now();
    });

    if (mounted) {
      context.read<ScheduleCubit>().selectDate(_selectedDate);
    }

    await _loadDrawing();

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(l10n.testTimeSetTo(DateFormat('yyyy-MM-dd HH:mm', Localizations.localeOf(context).toString()).format(testTime))),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  /// Clear all events in the current book (not just those in view)
  Future<void> _clearAllEventsInBook() async {
    await ScheduleTestUtils.clearAllEventsInBook(_dbService, widget.book.id!);
  }

  Future<void> _generateRandomEvents(
    int count, {
    bool clearAll = false,
    bool openEndOnly = false,
  }) async {
    // Clear existing events if requested
    if (clearAll) {
      await _clearAllEventsInBook();
    }

    final l10n = AppLocalizations.of(context)!;
    final random = Random();
    final now = TimeService.instance.now();

    // Get available event types
    final eventTypes = [
      l10n.consultation,
      l10n.surgery,
      l10n.followUp,
      l10n.emergency,
      l10n.checkUp,
      l10n.treatment,
    ];

    // Get date range for 3-day view
    final windowStart = _get3DayWindowStart_LOCAL(_selectedDate);
    final availableDates = List.generate(3, (i) => windowStart.add(Duration(days: i)));

    int created = 0;
    int attempts = 0;
    final maxAttempts = count * 10; // Prevent infinite loop

    while (created < count && attempts < maxAttempts) {
      attempts++;

      // Random date from available dates
      final date = availableDates[random.nextInt(availableDates.length)];

      // Random time slot (9 AM - 9 PM, 15-min intervals)
      final slotIndex = random.nextInt(_totalSlots);
      final hour = _startHour + (slotIndex ~/ 4);
      final minute = (slotIndex % 4) * 15;

      final startTime = DateTime(date.year, date.month, date.day, hour, minute);

      // Check if this time slot already has 4 events
      final cubitState = context.read<ScheduleCubit>().state;
      final currentEvents = cubitState is ScheduleLoaded ? cubitState.events : <Event>[];
      final eventsAtSlot = currentEvents.where((e) {
        return e.startTime.year == startTime.year &&
               e.startTime.month == startTime.month &&
               e.startTime.day == startTime.day &&
               e.startTime.hour == startTime.hour &&
               e.startTime.minute == startTime.minute;
      }).length;

      if (eventsAtSlot >= 4) {
        continue; // Skip this slot, try another
      }

      // Random duration (15, 30, 45, or 60 minutes) or null for open-ended
      DateTime? endTime;
      if (!openEndOnly) {
        final durations = [15, 30, 45, 60];
        final duration = durations[random.nextInt(durations.length)];
        endTime = startTime.add(Duration(minutes: duration));
      }

      // Random event type
      final eventType = eventTypes[random.nextInt(eventTypes.length)];

      // Random name
      final names = [
        'ÁéãÂ∞èÊòé', 'ÊùéÂ∞èËèØ', 'ÂºµÁæéÁé≤', 'Èô≥ÂøóË±™',
        'ÊûóÊ∑ëËä¨', 'ÈªÉÂª∫Âúã', 'Âê≥ÈõÖÂ©∑', 'ÈÑ≠ÊòéÂì≤',
        'Âäâ‰Ω≥Á©é', 'Ë®±ÊñáÁ••', 'Ê•äÊ∑ëÊÉ†', 'Ëî°ÊòéÈÅì',
      ];
      final name = names[random.nextInt(names.length)];

      // Random record number
      final recordNumber = 'REC-${random.nextInt(90000) + 10000}';

      final event = Event(
        bookId: widget.book.id!,
        name: name,
        recordNumber: recordNumber,
        eventType: eventType,
        startTime: startTime,
        endTime: endTime,
        createdAt: now,
        updatedAt: now,
      );

      try {
        final createdEvent = await _dbService.createEvent(event);
        created++;

        // Generate and save random handwriting note for this event
        if (createdEvent.id != null) {
          try {
            // Generate 3-15 random strokes for the note
            final strokeCount = 3 + random.nextInt(13);
            final strokes = ScheduleTestUtils.generateRandomStrokes(strokeCount);
            final note = Note(
              eventId: createdEvent.id!,
              strokes: strokes,
              createdAt: now,
              updatedAt: now,
              isDirty: true, // Mark as dirty so it syncs to server when first opened
            );
            await _dbService.saveCachedNote(note);
            debugPrint('‚úÖ Generated note with ${strokes.length} strokes for event ${createdEvent.id}');
          } catch (e) {
            debugPrint('‚ö†Ô∏è Error creating random note for event ${createdEvent.id}: $e');
          }
        }
      } catch (e) {
        debugPrint('Error creating random event: $e');
      }
    }

    // Reload events to show the new ones

    if (mounted) {
      final l10n = AppLocalizations.of(context)!;
      String message;
      if (clearAll && openEndOnly) {
        message = created == count
            ? l10n.clearedAndGeneratedOpenEndedEvents(created)
            : l10n.clearedAndGeneratedOpenEndedEventsSomeFull(created);
      } else if (clearAll) {
        message = created == count
            ? l10n.clearedAndGeneratedEvents(created)
            : l10n.clearedAndGeneratedEventsSomeFull(created);
      } else if (openEndOnly) {
        message = created == count
            ? l10n.generatedOpenEndedEvents(created)
            : l10n.generatedOpenEndedEventsSomeFull(created);
      } else {
        message = created == count
            ? l10n.generatedEvents(created)
            : l10n.generatedEventsSomeFull(created);
      }

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(message)),
      );
    }
  }

  /// Show heavy load test confirmation dialog
  Future<void> _showHeavyLoadTestDialog() async {
    await ScheduleTestUtils.showHeavyLoadTestDialog(
      context,
      _dbService,
      widget.book.id!,
      _progressController,
    );
  }

  /// Show Stage 1 Only confirmation dialog
  Future<void> _showHeavyLoadStage1Dialog() async {
    await ScheduleTestUtils.showHeavyLoadStage1Dialog(
      context,
      _dbService,
      widget.book.id!,
      _progressController,
    );
  }

  /// Show Stage 2 Only confirmation dialog
  Future<void> _showHeavyLoadStage2Dialog() async {
    await ScheduleTestUtils.showHeavyLoadStage2Dialog(
      context,
      _dbService,
      widget.book.id!,
      _progressController,
    );
  }

  /// Show Clear All Events confirmation dialog
  Future<void> _showClearAllEventsDialog() async {
    await ScheduleTestUtils.showClearAllEventsDialog(
      context,
      _dbService,
      widget.book.id!,
    );
  }

  /// Show Clear Cache dialog with cached event names
  Future<void> _showClearCacheDialog() async {
    // Get events from cubit state
    final cubitState = context.read<ScheduleCubit>().state;
    final events = cubitState is ScheduleLoaded ? cubitState.events : <Event>[];

    await ScheduleCacheUtils.showClearCacheDialog(
      context: context,
      cacheManager: _cacheManager,
      events: events,
      dbService: _dbService,
      bookId: widget.book.id!,
      effectiveDate: _getEffectiveDate_LOCAL(),
      onReloadDrawing: _loadDrawing,
      onPreloadNotes: () {
        // Wrapper to get events from cubit and pass to preload function
        final state = context.read<ScheduleCubit>().state;
        if (state is ScheduleLoaded) {
          _preloadNotesInBackground(state.events);
        }
      },
    );
  }


  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return BlocListener<ScheduleCubit, ScheduleState>(
      listener: (context, state) {
        // Trigger preloading when events are loaded
        if (state is ScheduleLoaded) {
          _preloadNotesInBackground(state.events);
        }
      },
      child: PopScope(
        canPop: false,
        onPopInvokedWithResult: (bool didPop, dynamic result) async {
          if (didPop) return;

          // Auto-save drawing before navigating back
          if (_isDrawingMode) {
            await _saveDrawing();
          }

          if (mounted) {
            Navigator.of(context).pop();
          }
        },
        child: Scaffold(
      appBar: AppBar(
        title: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            // Date navigation - Previous button
            IconButton(
              onPressed: () async {
                if (_isDrawingMode) {
                  _saveDebounceTimer?.cancel();
                  await _saveDrawing();
                }
                setState(() {
                  _selectedDate = _selectedDate.subtract(_getNavigationIncrement());
                });

                context.read<ScheduleCubit>().selectDate(_selectedDate);
                await _loadDrawing();
              },
              icon: const Icon(Icons.chevron_left, size: 18),
              iconSize: 18,
              constraints: const BoxConstraints(minWidth: 28, minHeight: 28),
              padding: EdgeInsets.zero,
            ),
            const SizedBox(width: 4),
            // Date display
            GestureDetector(
              onTap: () async {
                final date = await showDatePicker(
                  context: context,
                  initialDate: _selectedDate,
                  firstDate: DateTime.now().subtract(const Duration(days: 365)),
                  lastDate: DateTime.now().add(const Duration(days: 365)),
                );
                if (date != null) {
                  if (_isDrawingMode) {
                    _saveDebounceTimer?.cancel();
                    await _saveDrawing();
                  }
                  setState(() {
                    _selectedDate = date;
                  });

                  context.read<ScheduleCubit>().selectDate(_selectedDate);
                  await _loadDrawing();
                }
              },
              child: Text(
                _getDateDisplayText(),
                style: const TextStyle(
                  color: Colors.black,
                  fontSize: 13,
                ),
                textAlign: TextAlign.center,
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
            const SizedBox(width: 4),
            // Date navigation - Next button
            IconButton(
              onPressed: () async {
                if (_isDrawingMode) {
                  _saveDebounceTimer?.cancel();
                  await _saveDrawing();
                }
                setState(() {
                  _selectedDate = _selectedDate.add(_getNavigationIncrement());
                });

                context.read<ScheduleCubit>().selectDate(_selectedDate);
                await _loadDrawing();
              },
              icon: const Icon(Icons.chevron_right, size: 18),
              iconSize: 18,
              constraints: const BoxConstraints(minWidth: 28, minHeight: 28),
              padding: EdgeInsets.zero,
            ),
          ],
        ),
        actions: [
          // Toggle old events visibility
          BlocBuilder<ScheduleCubit, ScheduleState>(
            builder: (context, state) {
              final showOldEvents = state is ScheduleLoaded ? state.showOldEvents : true;
              return IconButton(
                icon: Icon(showOldEvents ? Icons.visibility : Icons.visibility_off),
                onPressed: () {
                  context.read<ScheduleCubit>().toggleOldEvents();
                },
                tooltip: showOldEvents ? l10n.hideOldEvents : l10n.showOldEvents,
              );
            },
          ),
          // Go to today button
          IconButton(
            icon: const Icon(Icons.today),
            onPressed: () async {
              if (_isDrawingMode) {
                _saveDebounceTimer?.cancel();
                await _saveDrawing();
              }
              setState(() {
                _selectedDate = TimeService.instance.now();
                _lastActiveDate = TimeService.instance.now();
              });

              context.read<ScheduleCubit>().selectDate(_selectedDate);
              await _loadDrawing();
              _panToCurrentTime();
            },
            tooltip: l10n.goToToday,
          ),
        ],
      ),
      body: BlocBuilder<ScheduleCubit, ScheduleState>(
        builder: (context, state) {
          // Handle error state
          if (state is ScheduleError) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(Icons.error_outline, size: 48, color: Colors.red),
                  const SizedBox(height: 16),
                  Text('Error: ${state.message}'),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: () => context.read<ScheduleCubit>().loadEvents(),
                    child: const Text('Retry'),
                  ),
                ],
              ),
            );
          }

          final isLoading = state is ScheduleLoading;
          final events = state is ScheduleLoaded ? state.events : <Event>[];
          final showOldEvents = state is ScheduleLoaded ? state.showOldEvents : true;

          return Stack(
            children: [
              Column(
                children: [
                  Expanded(
                    child: isLoading
                        ? const Center(child: CircularProgressIndicator())
                        : _build3DayView(events, showOldEvents),
                  ),
                ],
              ),
          // Drawing toolbar overlay (positioned on top of date header)
          if (_isDrawingMode)
            Positioned(
              top: 0,
              left: 0,
              right: 0,
              child: _buildDrawingToolbar(),
            ),
          // Event context menu overlay
          if (_buildEventContextMenuOverlay(events) != null)
            _buildEventContextMenuOverlay(events)!,
            ],
          );
        },
      ), // BlocBuilder
      floatingActionButton: _isFabMenuVisible
        ? Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              // Toggle FAB to hide menu
              FloatingActionButton(
                heroTag: 'toggle_fab_menu',
                onPressed: _toggleFabMenu,
                backgroundColor: Colors.grey.shade600,
                child: const Icon(Icons.close),
                tooltip: 'Hide menu',
              ),
              const SizedBox(height: 12),
              // Test Time FAB (for testing time change behavior)
              Builder(
                builder: (context) {
                  final l10n = AppLocalizations.of(context)!;
                  return FloatingActionButton(
                    heroTag: 'test_time',
                    onPressed: _showTestTimeDialog,
                    backgroundColor: TimeService.instance.isTestMode ? Colors.red : Colors.grey.shade700,
                    child: Icon(
                      TimeService.instance.isTestMode ? Icons.schedule : Icons.access_time,
                    ),
                    tooltip: TimeService.instance.isTestMode ? l10n.resetToRealTime : l10n.testTimeActive,
                  );
                },
              ),
          const SizedBox(height: 12),
          // Go to Today FAB (only show when not viewing today)
          if (!_isViewingToday_LOCAL())
            FloatingActionButton(
              heroTag: 'goto_today',
              onPressed: () async {
                if (_isDrawingMode) await _saveDrawing();
                setState(() {
                  _selectedDate = TimeService.instance.now();
                  _lastActiveDate = TimeService.instance.now();
                });

                context.read<ScheduleCubit>().selectDate(_selectedDate);

                await _loadDrawing();
              },
              backgroundColor: Colors.green,
              child: const Icon(Icons.today),
              tooltip: AppLocalizations.of(context)!.goToTodayTooltip,
            ),
          if (!_isViewingToday_LOCAL())
            const SizedBox(height: 12),
          // Generate random events FAB (disabled in drawing mode)
          FloatingActionButton(
            heroTag: 'generate_events',
            onPressed: _isDrawingMode ? null : _showGenerateEventsDialog,
            backgroundColor: _isDrawingMode ? Colors.grey : Colors.purple,
            child: const Icon(Icons.science),
            tooltip: _isDrawingMode ? null : 'Generate Random Events',
          ),
          const SizedBox(height: 12),
          // Clear all events FAB (disabled in drawing mode)
          FloatingActionButton(
            heroTag: 'clear_all_events',
            onPressed: _isDrawingMode ? null : _showClearAllEventsDialog,
            backgroundColor: _isDrawingMode ? Colors.grey : Colors.red.shade700,
            child: const Icon(Icons.delete_sweep),
            tooltip: _isDrawingMode ? null : 'Ê∏ÖÈô§ÊâÄÊúâÊ¥ªÂãï',
          ),
          const SizedBox(height: 12),
          // Heavy load test Stage 1 FAB (disabled in drawing mode)
          FloatingActionButton(
            heroTag: 'heavy_load_stage1',
            onPressed: _isDrawingMode ? null : _showHeavyLoadStage1Dialog,
            backgroundColor: _isDrawingMode ? Colors.grey : Colors.blue,
            child: const Icon(Icons.create),
            tooltip: _isDrawingMode ? null : l10n.heavyLoadStage1Only,
          ),
          const SizedBox(height: 12),
          // Heavy load test Stage 2 FAB (disabled in drawing mode)
          FloatingActionButton(
            heroTag: 'heavy_load_stage2',
            onPressed: _isDrawingMode ? null : _showHeavyLoadStage2Dialog,
            backgroundColor: _isDrawingMode ? Colors.grey : Colors.indigo,
            child: const Icon(Icons.draw),
            tooltip: _isDrawingMode ? null : l10n.heavyLoadStage2Only,
          ),
          const SizedBox(height: 12),
          // Heavy load test FAB (disabled in drawing mode)
          FloatingActionButton(
            heroTag: 'heavy_load_test',
            onPressed: _isDrawingMode ? null : _showHeavyLoadTestDialog,
            backgroundColor: _isDrawingMode ? Colors.grey : Colors.deepOrange,
            child: const Icon(Icons.warning_amber),
            tooltip: _isDrawingMode ? null : l10n.heavyLoadTest,
          ),
          const SizedBox(height: 12),
          // Clear Cache FAB (experimental - for testing cache mechanism)
          FloatingActionButton(
            heroTag: 'clear_cache',
            onPressed: _isDrawingMode ? null : _showClearCacheDialog,
            backgroundColor: _isDrawingMode ? Colors.grey : Colors.amber.shade700,
            child: const Icon(Icons.cached),
            tooltip: _isDrawingMode ? null : 'Clear Cache (Test)',
          ),
          const SizedBox(height: 12),
          // Drawing mode toggle FAB
          FloatingActionButton(
            heroTag: 'drawing_toggle',
            onPressed: _toggleDrawingMode,
            backgroundColor: _isDrawingMode ? Colors.orange : Colors.blue,
            child: Icon(_isDrawingMode ? Icons.draw : Icons.draw_outlined),
            tooltip: _isDrawingMode ? 'Exit Drawing Mode' : 'Enter Drawing Mode',
          ),
          const SizedBox(height: 12),
          // Create event FAB (disabled in drawing mode)
          FloatingActionButton(
            heroTag: 'create_event',
            onPressed: _isDrawingMode ? null : () => _createEvent(),
            backgroundColor: _isDrawingMode ? Colors.grey : null,
            child: const Icon(Icons.add),
            tooltip: l10n.createEvent,
          ),
        ],
      )
        : FloatingActionButton(
            heroTag: 'toggle_fab_menu',
            onPressed: _toggleFabMenu,
            backgroundColor: Colors.grey.shade600,
            child: const Icon(Icons.menu),
            tooltip: 'Show menu',
          ),
    ), // Scaffold
    ), // PopScope
    ); // BlocListener
  }

  String _getDateDisplayText() {
    // Always show 3-day range
    final windowStart = _get3DayWindowStart_LOCAL(_selectedDate);
    final windowEnd = windowStart.add(const Duration(days: 2));
    return '${DateFormat('MMM d', Localizations.localeOf(context).toString()).format(windowStart)} - ${DateFormat('MMM d, y', Localizations.localeOf(context).toString()).format(windowEnd)}';
  }

  Widget _build3DayView(List<Event> events, bool showOldEvents) {
    // Use stable 3-day window instead of _selectedDate to prevent page changes on date changes
    final windowStart = _get3DayWindowStart_LOCAL(_selectedDate);
    final dates = List.generate(3, (index) => windowStart.add(Duration(days: index)));
    return _buildTimeSlotView(dates, _getCanvasKeyForCurrentPage(), events, showOldEvents);
  }

  Widget _buildTimeSlotView(
    List<DateTime> dates,
    GlobalKey<HandwritingCanvasState> canvasKey,
    List<Event> events,
    bool showOldEvents,
  ) {
    final now = TimeService.instance.now();

    return LayoutBuilder(
      builder: (context, constraints) {
        // Calculate dynamic slot height to fit screen perfectly
        final dateHeaderHeight = dates.length > 1 ? 50.0 : 0.0;
        final availableHeightForSlots = constraints.maxHeight - dateHeaderHeight;
        final slotHeight = availableHeightForSlots / _totalSlots;

        // Content dimensions - exactly match screen
        final contentWidth = constraints.maxWidth;
        final contentHeight = constraints.maxHeight;

        debugPrint('üìê Schedule Layout: constraints=(${constraints.maxWidth.toStringAsFixed(2)}, ${constraints.maxHeight.toStringAsFixed(2)}) dateHeader=${dateHeaderHeight.toStringAsFixed(2)} availableForSlots=${availableHeightForSlots.toStringAsFixed(2)} viewMode=3day drawingMode=$_isDrawingMode');

        return InteractiveViewer(
          transformationController: _transformationController,
          minScale: 1.0, // Cannot zoom out - this IS the most zoomed out
          maxScale: 4.0, // Max zoom in
          boundaryMargin: EdgeInsets.zero, // Strict boundaries - no blank space
          constrained: true, // Respect size constraints
          panEnabled: !_isDrawingMode, // Disable pan when drawing
          scaleEnabled: true, // Always allow pinch zoom
          child: SizedBox(
            width: contentWidth,
            height: contentHeight,
            child: Column(
              children: [
                // Date headers - zoom/pan with content
                if (dates.length > 1)
                  Container(
                    height: dateHeaderHeight,
                    child: Row(
                      children: [
                        const SizedBox(width: 60), // Time column width
                        ...dates.map((date) => Expanded(
                          child: Container(
                            alignment: Alignment.center,
                            decoration: BoxDecoration(
                              border: Border.all(color: Colors.grey.shade300),
                            ),
                            child: Text(
                              DateFormat('EEE d', Localizations.localeOf(context).toString()).format(date),
                              style: Theme.of(context).textTheme.titleSmall,
                            ),
                          ),
                        )),
                      ],
                    ),
                  ),
                // Time slots + events + drawing overlay
                Expanded(
                  child: Stack(
                    children: [
                      // Schedule grid (dimmed when in drawing mode)
                      Opacity(
                        opacity: _isDrawingMode ? 0.6 : 1.0,
                        child: AbsorbPointer(
                          absorbing: _isDrawingMode, // Disable event interactions in drawing mode
                          child: Stack(
                            children: [
                              // Time slot grid
                              Column(
                                children: List.generate(_totalSlots, (index) {
                                  return _buildTimeSlot(index, dates, slotHeight);
                                }),
                              ),
                              // Current time indicator
                              _buildCurrentTimeIndicator(dates, now, slotHeight),
                              // Events overlay - positioned absolutely to span multiple slots
                              _buildEventsOverlay(dates, slotHeight, dateHeaderHeight, events, showOldEvents),
                            ],
                          ),
                        ),
                      ),
                      // Drawing overlay - same coordinate space as grid
                      IgnorePointer(
                        ignoring: !_isDrawingMode, // Only allow drawing when in drawing mode
                        child: HandwritingCanvas(
                          key: canvasKey,
                          initialStrokes: _currentDrawing?.strokes ?? [],
                          onStrokesChanged: () {
                            setState(() {}); // Rebuild toolbar to update undo/redo/clear buttons
                            // RACE CONDITION FIX: Schedule debounced save instead of immediate save
                            // This reduces server load and prevents race conditions during fast drawing
                            _scheduleSaveDrawing();
                          },
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildCurrentTimeIndicator(List<DateTime> dates, DateTime now, double slotHeight) {
    // Only show indicator if current time is within visible range
    if (now.hour < _startHour || now.hour >= _endHour) {
      return const SizedBox.shrink();
    }

    // Calculate the precise position based on current time relative to _startHour
    final totalMinutesFromStart = (now.hour - _startHour) * 60 + now.minute;
    final minutesPerSlot = 15;
    // Calculate absolute position from top of the content
    final yPosition = (totalMinutesFromStart / minutesPerSlot) * slotHeight;

    return Positioned(
      top: yPosition,
      left: 0,
      right: 0,
      child: IgnorePointer(
        child: Row(
          children: [
            const SizedBox(width: 60), // Time column offset
            ...dates.asMap().entries.map((entry) {
              final date = entry.value;
              final isToday = date.year == now.year &&
                             date.month == now.month &&
                             date.day == now.day;

              return Expanded(
                child: isToday
                    ? CustomPaint(
                        painter: const CurrentTimeLinePainter(),
                        size: const Size(double.infinity, 2),
                      )
                    : const SizedBox.shrink(),
              );
            }),
          ],
        ),
      ),
    );
  }

  Widget _buildTimeSlot(int index, List<DateTime> dates, double slotHeight) {
    final hour = _startHour + (index ~/ 4);
    final minute = (index % 4) * 15;
    final timeStr = '${hour.toString().padLeft(2, '0')}:${minute.toString().padLeft(2, '0')}';

    return Container(
      height: slotHeight,
      child: Row(
        children: [
          // Time label - only show on hour boundaries
          Container(
            width: 60,
            alignment: Alignment.topCenter,
            padding: const EdgeInsets.only(top: 1),
            child: Text(
              timeStr,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                fontSize: 10,
              ),
            ),
          ),
          // Grid cells for each date (events rendered separately in overlay)
          ...dates.map((date) {
            return Expanded(
              child: DragTarget<Event>(
                onWillAcceptWithDetails: (details) => !_isDrawingMode,
                onAcceptWithDetails: (details) {
                  final newStartTime = DateTime(date.year, date.month, date.day, hour, minute);
                  _handleEventDrop(details.data, newStartTime);
                },
                builder: (context, candidateData, rejectedData) {
                  final isHovering = candidateData.isNotEmpty;
                  return GestureDetector(
                    onTap: () {
                      if (_selectedEventForMenu != null) {
                        _closeEventMenu();
                      } else {
                        final startTime = DateTime(date.year, date.month, date.day, hour, minute);
                        _createEvent(startTime: startTime);
                      }
                    },
                    child: Container(
                      height: slotHeight,
                      decoration: BoxDecoration(
                        border: Border.all(
                          color: isHovering ? Colors.blue.shade300 : Colors.grey.shade400,
                          width: isHovering ? 2.0 : 0.5,
                        ),
                        color: isHovering ? Colors.blue.shade50.withOpacity(0.3) : null,
                      ),
                    ),
                  );
                },
              ),
            );
          }),
        ],
      ),
    );
  }

  /// Determine if an event should be displayed as open-end (single slot)
  bool _shouldDisplayAsOpenEnd_LOCAL(Event event) {
    // Removed events or old events with new time should be displayed as open-end (single slot)
    // NEW events (isTimeChanged) should display normally with full duration
    return event.isRemoved || event.hasNewTime || event.isOpenEnded;
  }

  /// Get the display duration in minutes for an event
  int _getDisplayDurationInMinutes_LOCAL(Event event) {
    if (_shouldDisplayAsOpenEnd_LOCAL(event)) {
      return 15; // Always 15 minutes (1 slot) for open-end display
    }
    return event.durationInMinutes ?? 15;
  }

  /// Build events overlay with absolute positioning to allow spanning multiple time slots
  Widget _buildEventsOverlay(List<DateTime> dates, double slotHeight, double dateHeaderHeight, List<Event> events, bool showOldEvents) {
    return Row(
      children: [
        const SizedBox(width: 60), // Time column width
        ...dates.map((date) {
          final dateEvents = _getEventsForDate_LOCAL(date, events, showOldEvents);

          return Expanded(
            child: LayoutBuilder(
              builder: (context, constraints) {
                final availableWidth = constraints.maxWidth - 4; // Account for padding/borders

                // Build slot occupancy map: slot index -> set of occupied horizontal positions
                final Map<int, Set<int>> slotOccupancy = {};

                // Group events by start time slot
                final Map<int, List<Event>> eventsBySlot = {};
                for (final event in dateEvents) {
                  final slotIndex = _getSlotIndexForTime_LOCAL(event.startTime);
                  eventsBySlot.putIfAbsent(slotIndex, () => []).add(event);
                }

                // Calculate concurrent event count per time slot
                final Map<int, int> slotEventCount = {};

                for (final event in dateEvents) {
                  final slotIndex = _getSlotIndexForTime_LOCAL(event.startTime);
                  final durationInMinutes = _getDisplayDurationInMinutes_LOCAL(event);
                  final slotsSpanned = ((durationInMinutes / 15).ceil()).clamp(1, 48);

                  // Increment count for all slots this event occupies
                  for (int spanOffset = 0; spanOffset < slotsSpanned; spanOffset++) {
                    final occupiedSlot = slotIndex + spanOffset;
                    slotEventCount[occupiedSlot] = (slotEventCount[occupiedSlot] ?? 0) + 1;
                  }
                }

                // Build positioned widgets
                final List<Widget> positionedWidgets = [];

                // Process events in order of time slots
                final sortedSlotIndices = eventsBySlot.keys.toList()..sort();

                for (final slotIndex in sortedSlotIndices) {
                  final slotEvents = eventsBySlot[slotIndex]!;

                  // Separate close-end and open-end events
                  final closeEndEvents = slotEvents.where((e) => !_shouldDisplayAsOpenEnd_LOCAL(e)).toList();
                  final openEndEvents = slotEvents.where((e) => _shouldDisplayAsOpenEnd_LOCAL(e)).toList();

                  // Sort each list by ID
                  closeEndEvents.sort((a, b) => (a.id ?? 0).compareTo(b.id ?? 0));
                  openEndEvents.sort((a, b) => (a.id ?? 0).compareTo(b.id ?? 0));

                  // Process in order: close-end events first, then open-end events
                  final orderedEvents = [...closeEndEvents, ...openEndEvents];

                  for (final event in orderedEvents) {
                    // Calculate display duration and slots spanned
                    final durationInMinutes = _getDisplayDurationInMinutes_LOCAL(event);
                    final slotsSpanned = ((durationInMinutes / 15).ceil()).clamp(1, 48);

                    // Calculate max concurrent events for this specific event across all slots it spans
                    int maxConcurrentForThisEvent = 4; // Default minimum of 4
                    for (int spanOffset = 0; spanOffset < slotsSpanned; spanOffset++) {
                      final checkSlot = slotIndex + spanOffset;
                      final concurrentInSlot = slotEventCount[checkSlot] ?? 0;
                      maxConcurrentForThisEvent = max(maxConcurrentForThisEvent, concurrentInSlot);
                    }

                    // Calculate event width: keep 25% for up to 4 events, adjust for this event's specific grid
                    final eventWidth = availableWidth / maxConcurrentForThisEvent;

                    // Find leftmost available horizontal position across all spanned slots
                    int horizontalPosition = 0;
                    bool positionFound = false;

                    for (int pos = 0; pos < maxConcurrentForThisEvent; pos++) {
                      bool positionAvailable = true;

                      // Check if this position is available in all spanned slots
                      for (int spanOffset = 0; spanOffset < slotsSpanned; spanOffset++) {
                        final checkSlot = slotIndex + spanOffset;
                        if (slotOccupancy[checkSlot]?.contains(pos) ?? false) {
                          positionAvailable = false;
                          break;
                        }
                      }

                      if (positionAvailable) {
                        horizontalPosition = pos;
                        positionFound = true;
                        break;
                      }
                    }

                    // If no position found, skip this event (should not happen with dynamic positioning)
                    if (!positionFound) {
                      debugPrint('‚ö†Ô∏è No position found for event ${event.id} at slot $slotIndex (max concurrent: $maxConcurrentForThisEvent)');
                      continue;
                    }

                    // Mark position as occupied in all spanned slots
                    for (int spanOffset = 0; spanOffset < slotsSpanned; spanOffset++) {
                      final occupySlot = slotIndex + spanOffset;
                      slotOccupancy.putIfAbsent(occupySlot, () => {}).add(horizontalPosition);
                    }

                    // Calculate position and height
                    final topPosition = _calculateEventTopPosition(event, slotHeight);
                    final tileHeight = (slotsSpanned * slotHeight) - 1; // Subtract margin

                    // Create positioned widget
                    positionedWidgets.add(
                      Positioned(
                        top: topPosition,
                        left: horizontalPosition * eventWidth,
                        width: eventWidth,
                        height: tileHeight,
                        child: Padding(
                          padding: const EdgeInsets.only(left: 1, right: 1, top: 1),
                          child: _buildEventTile(context, event, slotHeight, events),
                        ),
                      ),
                    );
                  }
                }

                return Stack(
                  clipBehavior: Clip.none,
                  children: positionedWidgets,
                );
              },
            ),
          );
        }),
      ],
    );
  }

  /// Get slot index (0-47) for a given time
  int _getSlotIndexForTime_LOCAL(DateTime time) {
    final minutesFromStart = (time.hour - _startHour) * 60 + time.minute;
    return minutesFromStart ~/ 15;
  }

  /// Get all events for a specific date (used for overlay rendering)
  List<Event> _getEventsForDate_LOCAL(DateTime date, List<Event> events, bool showOldEvents) {
    return events.where((event) {
      // Filter by date
      final matchesDate = event.startTime.year == date.year &&
                          event.startTime.month == date.month &&
                          event.startTime.day == date.day;

      if (!matchesDate) return false;

      // Filter out old events if toggle is off
      // Old events = removed events or time-changed old versions
      if (!showOldEvents && (event.isRemoved || event.hasNewTime)) {
        return false;
      }

      return true;
    }).toList();
  }

  /// Calculate the Y position offset for an event based on its start time
  double _calculateEventTopPosition(Event event, double slotHeight) {
    final totalMinutesFromStart = (event.startTime.hour - _startHour) * 60 + event.startTime.minute;
    final minutesPerSlot = 15;
    return (totalMinutesFromStart / minutesPerSlot) * slotHeight;
  }

  /// Get the new event that this event was moved to (if it has a newEventId)
  Event? _getNewEventForTimeChange_LOCAL(Event event, List<Event> events) {
    if (event.newEventId == null) return null;
    try {
      return events.firstWhere((e) => e.id == event.newEventId);
    } catch (e) {
      return null;
    }
  }

  /// Format the new time info for display
  String _getNewTimeDisplay(Event? newEvent) {
    if (newEvent == null) return '';
    return '‚Üí ${DateFormat('MMM d, HH:mm', Localizations.localeOf(context).toString()).format(newEvent.startTime)}';
  }

  Widget _buildEventTile(BuildContext context, Event event, double slotHeight, List<Event> events) {
    // Calculate how many 15-minute slots this event spans
    final durationInMinutes = _getDisplayDurationInMinutes_LOCAL(event);
    final slotsSpanned = ((durationInMinutes / 15).ceil()).clamp(1, 16); // Max 4 hours
    final tileHeight = (slotsSpanned * slotHeight) - 1; // Subtract margin

    final isMenuOpen = _selectedEventForMenu?.id == event.id;

    Widget eventWidget = GestureDetector(
      onTap: isMenuOpen ? null : () => _editEvent(event),
      onLongPressStart: (details) {
        if (!isMenuOpen) {
          _showEventContextMenu(event, details.globalPosition);
        }
      },
      child: Container(
        height: tileHeight,
        margin: const EdgeInsets.only(left: 1, right: 1, top: 1),
        padding: const EdgeInsets.symmetric(horizontal: 2, vertical: 0),
        decoration: BoxDecoration(
          color: event.isRemoved
              ? _getEventTypeColor(context, event.eventType).withOpacity(0.3)
              : _getEventTypeColor(context, event.eventType).withOpacity(0.75),
          borderRadius: BorderRadius.circular(2),
          border: isMenuOpen
              ? Border.all(color: Colors.white, width: 2)
              : event.isRemoved
              ? Border.all(
                  color: _getEventTypeColor(context, event.eventType).withOpacity(0.6),
                  width: 1,
                  style: BorderStyle.solid,
                )
              : null,
        ),
        child: Stack(
          children: [
            // Dotted line overlay for removed events
            if (event.isRemoved)
              Positioned.fill(
                child: CustomPaint(
                  painter: DottedBorderPainter(
                    color: _getEventTypeColor(context, event.eventType).withOpacity(0.8),
                    strokeWidth: 1,
                  ),
                ),
              ),
            // Content with height-adaptive rendering
            _buildEventTileContent(event, tileHeight, slotHeight, events),
          ],
        ),
      ),
    );

    // Make event draggable only when menu is open
    if (isMenuOpen) {
      eventWidget = Draggable<Event>(
        data: event,
        feedback: Material(
          elevation: 4,
          borderRadius: BorderRadius.circular(2),
          child: Opacity(
            opacity: 0.7,
            child: Container(
              width: 100,
              height: tileHeight,
              padding: const EdgeInsets.symmetric(horizontal: 2, vertical: 1),
              decoration: BoxDecoration(
                color: _getEventTypeColor(context, event.eventType),
                borderRadius: BorderRadius.circular(2),
              ),
              child: _buildEventTileContent(event, tileHeight, slotHeight, events),
            ),
          ),
        ),
        childWhenDragging: Opacity(
          opacity: 0.3,
          child: eventWidget,
        ),
        onDragEnd: (details) {
          // Drag ended, no action needed
        },
        child: eventWidget,
      );
    }

    return eventWidget;
  }

  /// Helper method to calculate event name font size based on slot height
  /// Returns scaled font size (1.8x) for large screens, or original size for smaller screens
  double _getEventNameFontSize_LOCAL(double slotHeight, double baseFontSize) {
    if (slotHeight >= ScheduleLayoutUtils.largeScreenSlotHeightThreshold) {
      return baseFontSize * 1.8;
    }
    return baseFontSize;
  }

  Widget _buildEventTileContent(Event event, double tileHeight, double slotHeight, List<Event> events) {
    // For closed-end events (with both start and end times), always show simplified content
    // Open-end events get height-adaptive rendering
    final isClosedEnd = !_shouldDisplayAsOpenEnd_LOCAL(event);

    if (isClosedEnd) {
      // Closed-end events: Always show just the name with consistent styling
      // Use fixed small font size to match open-end events (not calculated from tileHeight)
      final fontSize = _getEventNameFontSize_LOCAL(slotHeight, 9.0);
      return Align(
        alignment: Alignment.topLeft,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 2),
          child: Text(
            event.name,
            style: TextStyle(
              fontSize: fontSize,
              color: event.isRemoved ? Colors.white70 : Colors.white,
              height: 1.2,
              decoration: event.isRemoved ? TextDecoration.lineThrough : null,
              decorationColor: Colors.white70,
              fontWeight: FontWeight.bold,
            ),
            overflow: TextOverflow.ellipsis,
            maxLines: 1,
          ),
        ),
      );
    }

    // Open-end events: Height-adaptive rendering
    // Height breakpoints for adaptive rendering
    if (tileHeight < 20) {
      // Very small: Only show name with tiny font
      final baseFontSize = (tileHeight * 0.4).clamp(8.0, 10.0);
      final fontSize = _getEventNameFontSize_LOCAL(slotHeight, baseFontSize);
      return Align(
        alignment: Alignment.topLeft,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 2),
          child: Text(
            event.name,
            style: TextStyle(
              fontSize: fontSize,
              color: event.isRemoved ? Colors.white70 : Colors.white,
              height: 1.2,
              decoration: event.isRemoved ? TextDecoration.lineThrough : null,
              decorationColor: Colors.white70,
              fontWeight: FontWeight.bold,
            ),
            overflow: TextOverflow.ellipsis,
            maxLines: 1,
          ),
        ),
      );
    } else if (tileHeight < 35) {
      // Small: Only show name with small font
      final baseFontSize = (tileHeight * 0.35).clamp(8.0, 10.0);
      final fontSize = _getEventNameFontSize_LOCAL(slotHeight, baseFontSize);
      return Align(
        alignment: Alignment.topLeft,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 2),
          child: Text(
            event.name,
            style: TextStyle(
              fontSize: fontSize,
              color: event.isRemoved ? Colors.white70 : Colors.white,
              height: 1.2,
              decoration: event.isRemoved ? TextDecoration.lineThrough : null,
              decorationColor: Colors.white70,
              fontWeight: FontWeight.bold,
            ),
            overflow: TextOverflow.ellipsis,
            maxLines: 1,
          ),
        ),
      );
    } else if (tileHeight < 50) {
      // Medium: Show time + name
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisAlignment: MainAxisAlignment.start,
        children: [
          Text(
            event.timeRangeDisplay,
            style: TextStyle(
              fontSize: 8,
              fontWeight: FontWeight.bold,
              color: event.isRemoved ? Colors.white70 : Colors.white,
              height: 1.2,
              decoration: event.isRemoved ? TextDecoration.lineThrough : null,
              decorationColor: Colors.white70,
            ),
            overflow: TextOverflow.ellipsis,
            maxLines: 1,
          ),
          if (event.name.isNotEmpty)
            Expanded(
              child: Padding(
                padding: const EdgeInsets.only(top: 2),
                child: Text(
                  event.name,
                  style: TextStyle(
                    fontSize: _getEventNameFontSize_LOCAL(slotHeight, 12.6),
                    color: event.isRemoved ? Colors.white70 : Colors.white,
                    height: 1.3,
                    decoration: event.isRemoved ? TextDecoration.lineThrough : null,
                    decorationColor: Colors.white70,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ),
            ),
        ],
      );
    } else if (tileHeight < 70) {
      // Large: Show time + name + record number
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisAlignment: MainAxisAlignment.start,
        children: [
          Text(
            event.timeRangeDisplay,
            style: TextStyle(
              fontSize: 8,
              fontWeight: FontWeight.bold,
              color: event.isRemoved ? Colors.white70 : Colors.white,
              height: 1.2,
              decoration: event.isRemoved ? TextDecoration.lineThrough : null,
              decorationColor: Colors.white70,
            ),
            overflow: TextOverflow.ellipsis,
            maxLines: 1,
          ),
          if (event.name.isNotEmpty)
            Expanded(
              child: Padding(
                padding: const EdgeInsets.only(top: 4),
                child: Text(
                  event.name,
                  style: TextStyle(
                    fontSize: _getEventNameFontSize_LOCAL(slotHeight, 14.4),
                    color: event.isRemoved ? Colors.white70 : Colors.white,
                    height: 1.3,
                    decoration: event.isRemoved ? TextDecoration.lineThrough : null,
                    decorationColor: Colors.white70,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 2,
                ),
              ),
            ),
          if (event.recordNumber?.isNotEmpty ?? false)
            Builder(
              builder: (context) => Text(
                '${AppLocalizations.of(context)!.record}${event.recordNumber}',
                style: TextStyle(
                  fontSize: 7,
                  color: event.isRemoved ? Colors.white60 : Colors.white70,
                  height: 1.2,
                  decoration: event.isRemoved ? TextDecoration.lineThrough : null,
                  decorationColor: Colors.white60,
                ),
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
        ],
      );
    } else {
      // Extra large: Show all details
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisAlignment: MainAxisAlignment.start,
        children: [
          Text(
            event.timeRangeDisplay,
            style: TextStyle(
              fontSize: 8,
              fontWeight: FontWeight.bold,
              color: event.isRemoved ? Colors.white70 : Colors.white,
              height: 1.2,
              decoration: event.isRemoved ? TextDecoration.lineThrough : null,
              decorationColor: Colors.white70,
            ),
            overflow: TextOverflow.ellipsis,
            maxLines: 1,
          ),
          if (event.name.isNotEmpty)
            Expanded(
              child: Padding(
                padding: const EdgeInsets.only(top: 6),
                child: Text(
                  event.name,
                  style: TextStyle(
                    fontSize: _getEventNameFontSize_LOCAL(slotHeight, 16.2),
                    color: event.isRemoved ? Colors.white70 : Colors.white,
                    height: 1.3,
                    decoration: event.isRemoved ? TextDecoration.lineThrough : null,
                    decorationColor: Colors.white70,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 2,
                ),
              ),
            ),
          if (event.recordNumber?.isNotEmpty ?? false)
            Builder(
              builder: (context) => Text(
                '${AppLocalizations.of(context)!.record}${event.recordNumber}',
                style: TextStyle(
                  fontSize: 7,
                  color: event.isRemoved ? Colors.white60 : Colors.white70,
                  height: 1.2,
                  decoration: event.isRemoved ? TextDecoration.lineThrough : null,
                  decorationColor: Colors.white60,
                ),
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
          // Show new time if event was moved
          if (event.hasNewTime)
            Builder(
              builder: (context) {
                final newEvent = _getNewEventForTimeChange_LOCAL(event, events);
                final newTimeDisplay = _getNewTimeDisplay(newEvent);
                return Padding(
                  padding: const EdgeInsets.only(top: 2),
                  child: Text(
                    '${AppLocalizations.of(context)!.moved} $newTimeDisplay',
                    style: const TextStyle(
                      fontSize: 7,
                      color: Colors.white70,
                      height: 1.2,
                      fontWeight: FontWeight.bold,
                    ),
                    overflow: TextOverflow.ellipsis,
                    maxLines: 1,
                  ),
                );
              },
            ),
          // Show removal reason or time change indicator
          if ((event.isRemoved || event.isTimeChanged) && event.removalReason != null)
            Builder(
              builder: (context) => Padding(
                padding: const EdgeInsets.only(top: 2),
                child: Text(
                  event.isTimeChanged
                    ? AppLocalizations.of(context)!.timeChanged(event.removalReason!)
                    : AppLocalizations.of(context)!.removedReason(event.removalReason!),
                  style: const TextStyle(
                    fontSize: 6,
                    color: Colors.white60,
                    height: 1.2,
                    fontStyle: FontStyle.italic,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ),
            ),
        ],
      );
    }
  }

  Color _getEventTypeColor(BuildContext context, String eventType) {
    final l10n = AppLocalizations.of(context)!;

    Color baseColor;

    // Color coding based on localized event type
    if (eventType == l10n.consultation) {
      baseColor = Colors.blue;
    } else if (eventType == l10n.surgery) {
      baseColor = Colors.red;
    } else if (eventType == l10n.followUp) {
      baseColor = Colors.green;
    } else if (eventType == l10n.emergency) {
      baseColor = Colors.orange;
    } else if (eventType == l10n.checkUp) {
      baseColor = Colors.purple;
    } else if (eventType == l10n.treatment) {
      baseColor = Colors.cyan;
    } else {
      // Default color for unknown types
      baseColor = Colors.grey;
    }

    // Reduce saturation to 60%
    final hslColor = HSLColor.fromColor(baseColor);
    return hslColor.withSaturation(0.60).toColor();
  }

  Widget? _buildEventContextMenuOverlay(List<Event> events) {
    if (_selectedEventForMenu == null || _menuPosition == null) return null;

    final l10n = AppLocalizations.of(context)!;
    final event = _selectedEventForMenu!;
    final screenSize = MediaQuery.of(context).size;

    // Determine if menu should appear above or below
    final showAbove = _menuPosition!.dy > screenSize.height / 2;

    return Positioned(
      left: _menuPosition!.dx.clamp(20.0, screenSize.width - 200),
      top: showAbove ? null : _menuPosition!.dy + 10,
      bottom: showAbove ? screenSize.height - _menuPosition!.dy + 10 : null,
      child: Material(
        elevation: 8,
        borderRadius: BorderRadius.circular(8),
        child: Container(
          width: 200,
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: Colors.grey.shade300),
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              // Header
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.grey.shade100,
                  borderRadius: const BorderRadius.vertical(top: Radius.circular(8)),
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Expanded(
                      child: Text(
                        event.name.isEmpty ? AppLocalizations.of(context)!.eventOptions : event.name,
                        style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 14),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    IconButton(
                      icon: const Icon(Icons.close, size: 18),
                      padding: EdgeInsets.zero,
                      constraints: const BoxConstraints(),
                      onPressed: _closeEventMenu,
                    ),
                  ],
                ),
              ),
              const Divider(height: 1),
              // Menu items
              ListTile(
                dense: true,
                leading: const Icon(Icons.category, size: 20),
                title: Text(l10n.changeEventType, style: const TextStyle(fontSize: 14)),
                onTap: () => _handleMenuAction('changeType', event),
              ),
              ListTile(
                dense: true,
                leading: const Icon(Icons.access_time, size: 20),
                title: Text(l10n.changeEventTime, style: const TextStyle(fontSize: 14)),
                onTap: () => _handleMenuAction('changeTime', event),
              ),
              ListTile(
                dense: true,
                leading: const Icon(Icons.remove_circle_outline, color: Colors.orange, size: 20),
                title: Text(l10n.removeEvent, style: const TextStyle(color: Colors.orange, fontSize: 14)),
                onTap: () => _handleMenuAction('remove', event),
              ),
              ListTile(
                dense: true,
                leading: const Icon(Icons.delete, color: Colors.red, size: 20),
                title: Text(l10n.deleteEvent, style: const TextStyle(color: Colors.red, fontSize: 14)),
                onTap: () => _handleMenuAction('delete', event),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildDrawingToolbar() {
    final canvasState = _getCanvasKeyForCurrentPage().currentState;
    final isErasing = canvasState?.isErasing ?? false;
    final currentColor = canvasState?.strokeColor ?? Colors.black;

    return Container(
      height: 50,
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
      decoration: BoxDecoration(
        color: Colors.orange.shade50.withOpacity(0.95),
        border: Border(
          bottom: BorderSide(color: Colors.orange.shade300, width: 2),
        ),
      ),
      child: Row(
        children: [
          // Pen/Eraser toggle
          Container(
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(6),
              border: Border.all(color: Colors.grey.shade300),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                InkWell(
                  onTap: () => setState(() => canvasState?.setErasing(false)),
                  child: Container(
                    padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
                    decoration: BoxDecoration(
                      color: !isErasing ? Colors.blue.shade100 : Colors.transparent,
                      borderRadius: const BorderRadius.horizontal(left: Radius.circular(6)),
                    ),
                    child: Icon(
                      Icons.edit,
                      size: 18,
                      color: !isErasing ? Colors.blue.shade700 : Colors.grey.shade600,
                    ),
                  ),
                ),
                Container(width: 1, height: 20, color: Colors.grey.shade300),
                InkWell(
                  onTap: () => setState(() => canvasState?.setErasing(true)),
                  child: Container(
                    padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
                    decoration: BoxDecoration(
                      color: isErasing ? Colors.orange.shade100 : Colors.transparent,
                      borderRadius: const BorderRadius.horizontal(right: Radius.circular(6)),
                    ),
                    child: Icon(
                      Icons.auto_fix_high,
                      size: 18,
                      color: isErasing ? Colors.orange.shade700 : Colors.grey.shade600,
                    ),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(width: 12),
          // Color picker (only show when not erasing)
          if (!isErasing) ...[
            ...[ Colors.black,
              Colors.red,
              Colors.blue,
              Colors.green,
              Colors.orange,
              Colors.purple,
            ].map((color) {
              final isSelected = currentColor == color;
              return GestureDetector(
                onTap: () => setState(() => canvasState?.setStrokeColor(color)),
                child: Container(
                  width: 28,
                  height: 28,
                  margin: const EdgeInsets.only(right: 6),
                  decoration: BoxDecoration(
                    color: color,
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: isSelected ? Colors.white : Colors.grey.shade400,
                      width: isSelected ? 3 : 1,
                    ),
                    boxShadow: isSelected
                        ? [
                            BoxShadow(
                              color: Colors.black.withOpacity(0.3),
                              blurRadius: 4,
                              offset: const Offset(0, 2),
                            ),
                          ]
                        : null,
                  ),
                  child: isSelected
                      ? Icon(
                          Icons.check,
                          size: 14,
                          color: color.computeLuminance() > 0.5 ? Colors.black : Colors.white,
                        )
                      : null,
                ),
              );
            }),
          ],
          const Spacer(),
          // Action buttons
          Builder(
            builder: (context) {
              final l10n = AppLocalizations.of(context)!;
              return Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  IconButton(
                    icon: const Icon(Icons.undo, size: 20),
                    onPressed: canvasState?.canUndo ?? false ? () => setState(() => canvasState?.undo()) : null,
                    tooltip: l10n.undo,
                    padding: const EdgeInsets.all(4),
                    constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
                  ),
                  IconButton(
                    icon: const Icon(Icons.redo, size: 20),
                    onPressed: canvasState?.canRedo ?? false ? () => setState(() => canvasState?.redo()) : null,
                    tooltip: l10n.redo,
                    padding: const EdgeInsets.all(4),
                    constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
                  ),
                  IconButton(
                    icon: const Icon(Icons.delete_outline, size: 20),
                    onPressed: () {
                      setState(() => canvasState?.clear());
                      _saveDrawing();
                    },
                    tooltip: l10n.clear,
                    padding: const EdgeInsets.all(4),
                    constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
                  ),
                ],
              );
            },
          ),
        ],
      ),
    );
  }
}

/// Custom painter for drawing the current time indicator line
class CurrentTimeLinePainter extends CustomPainter {
  final Color color;
  final double strokeWidth;

  const CurrentTimeLinePainter({
    this.color = Colors.red,
    this.strokeWidth = 2.0,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = strokeWidth
      ..style = PaintingStyle.stroke;

    // Draw dashed line
    const dashWidth = 8.0;
    const dashSpace = 4.0;
    double startX = 0;

    while (startX < size.width) {
      canvas.drawLine(
        Offset(startX, 0),
        Offset(startX + dashWidth, 0),
        paint,
      );
      startX += dashWidth + dashSpace;
    }

    // Draw circles at both ends
    final circlePaint = Paint()
      ..color = color
      ..style = PaintingStyle.fill;
    canvas.drawCircle(Offset(0, 0), 4, circlePaint); // Left circle
    canvas.drawCircle(Offset(size.width, 0), 4, circlePaint); // Right circle
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

/// Custom painter for creating dotted border effect on removed events
class DottedBorderPainter extends CustomPainter {
  final Color color;
  final double strokeWidth;
  final double dashLength;
  final double gapLength;

  const DottedBorderPainter({
    required this.color,
    this.strokeWidth = 1.0,
    this.dashLength = 3.0,
    this.gapLength = 2.0,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = strokeWidth
      ..style = PaintingStyle.stroke;

    // Create dotted border path
    final path = Path();

    // Top border
    double currentX = 0;
    while (currentX < size.width) {
      path.moveTo(currentX, 0);
      path.lineTo((currentX + dashLength).clamp(0, size.width), 0);
      currentX += dashLength + gapLength;
    }

    // Right border
    double currentY = 0;
    while (currentY < size.height) {
      path.moveTo(size.width, currentY);
      path.lineTo(size.width, (currentY + dashLength).clamp(0, size.height));
      currentY += dashLength + gapLength;
    }

    // Bottom border
    currentX = size.width;
    while (currentX > 0) {
      path.moveTo(currentX, size.height);
      path.lineTo((currentX - dashLength).clamp(0, size.width), size.height);
      currentX -= dashLength + gapLength;
    }

    // Left border
    currentY = size.height;
    while (currentY > 0) {
      path.moveTo(0, currentY);
      path.lineTo(0, (currentY - dashLength).clamp(0, size.height));
      currentY -= dashLength + gapLength;
    }

    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}